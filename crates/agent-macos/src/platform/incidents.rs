/// Incident models for detected threats
///
/// Defines incidents generated by playbooks

use std::time::{SystemTime, UNIX_EPOCH};

/// Severity levels for incidents
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Severity {
    LOW = 1,
    MEDIUM = 2,
    HIGH = 3,
    CRITICAL = 4,
}

/// Pointer to evidence (a fact) supporting an incident
#[derive(Clone, Debug)]
pub struct EvidencePtr {
    /// Segment ID of the fact
    pub segment_id: String,
    /// Fact ID
    pub fact_id: String,
    /// Type of fact (e.g., "ProcExec", "NetConnect")
    pub fact_type: String,
    /// Timestamp of the fact
    pub ts: i64,
}

/// Incident detected by a playbook
#[derive(Clone, Debug)]
pub struct Incident {
    /// Unique incident ID
    pub incident_id: String,
    /// Playbook that generated this (A, B, C, D, E, F)
    pub playbook: String,
    /// Severity level
    pub severity: Severity,
    /// Confidence score (0.0 to 1.0)
    pub confidence: f64,
    /// Human-readable description
    pub description: String,
    /// Evidence pointers
    pub evidence: Vec<EvidencePtr>,
    /// Creation timestamp
    pub created_at: i64,
    /// Deduplication key for grouping similar incidents
    pub dedupe_key: String,
    /// Last occurrence timestamp (for deduplication)
    pub last_seen: i64,
    /// Occurrence count
    pub count: u32,
}

impl Incident {
    /// Check if incident is expired (TTL exceeded)
    pub fn is_expired(&self, ttl_secs: i64) -> bool {
        let now = now_ts();
        (now - self.created_at) > ttl_secs
    }

    /// Check if incident should be dedup'd based on key and window
    pub fn should_deduplicate(&self, other_key: &str, now_ts: i64, window_secs: i64) -> bool {
        self.dedupe_key == other_key && (now_ts - self.last_seen) < window_secs
    }
}

/// Factory for creating incidents with proper IDs and scoring
pub struct IncidentFactory;

impl IncidentFactory {
    /// Create a new incident
    pub fn create(
        playbook: &str,
        severity: Severity,
        confidence: f64,
        description: Option<String>,
    ) -> Incident {
        let now = now_ts();
        let incident_id = generate_incident_id();
        let dedupe_key = String::new(); // Would be set by caller

        Incident {
            incident_id,
            playbook: playbook.to_string(),
            severity,
            confidence: confidence.max(0.0).min(1.0),
            description: description.unwrap_or_default(),
            evidence: Vec::new(),
            created_at: now,
            dedupe_key,
            last_seen: now,
            count: 1,
        }
    }

    /// Create with evidence
    pub fn create_with_evidence(
        playbook: &str,
        severity: Severity,
        confidence: f64,
        description: Option<String>,
        evidence: Vec<EvidencePtr>,
    ) -> Incident {
        let mut incident = Self::create(playbook, severity, confidence, description);
        incident.evidence = evidence;
        incident
    }
}

/// Generate a unique incident ID
fn generate_incident_id() -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    let now = now_ts();
    let counter = (now % 1000000).to_string();
    
    let mut hasher = DefaultHasher::new();
    counter.hash(&mut hasher);
    let hash = hasher.finish();
    
    format!("inc-{}-{:x}", now, hash)
}

/// Get current timestamp in seconds
pub fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() as i64
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_incident_creation() {
        let incident = IncidentFactory::create(
            "A",
            Severity::HIGH,
            0.85,
            Some("Test incident".to_string()),
        );

        assert_eq!(incident.playbook, "A");
        assert_eq!(incident.severity, Severity::HIGH);
        assert_eq!(incident.confidence, 0.85);
    }

    #[test]
    fn test_incident_confidence_bounds() {
        let high_conf = IncidentFactory::create(
            "A",
            Severity::HIGH,
            1.5, // Should be clamped
            None,
        );

        assert_eq!(high_conf.confidence, 1.0);

        let neg_conf = IncidentFactory::create(
            "A",
            Severity::HIGH,
            -0.5, // Should be clamped
            None,
        );

        assert_eq!(neg_conf.confidence, 0.0);
    }

    #[test]
    fn test_incident_expiration() {
        let incident = IncidentFactory::create("A", Severity::HIGH, 0.9, None);
        
        // Fresh incident not expired
        assert!(!incident.is_expired(3600)); // 1 hour TTL
    }

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::CRITICAL > Severity::HIGH);
        assert!(Severity::HIGH > Severity::MEDIUM);
        assert!(Severity::MEDIUM > Severity::LOW);
    }
}
